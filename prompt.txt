Please check the current codebase, after the freeze the first generation of the Stern-I project as TAG STERN-Iv1, i wanne build the next generation with proces management support.

Herefore i did an CPU upgrade to the current cpu1.py, this new CPU supports the context switch instruction (cxtsw) i need for proces management.
the working od cxtsw is to 'return from interrupt and switch" "rts <adres>. since an context switch is (mostly) interrupt driven, the return part of the instuction will restore the state before the interrupt, the switch part will save the current context and load the new context to run. the ("pcb") information is stored in memory on the CPU

I changes the kernel (asm/kernel3.asm) so it know about the processes and schedule the processes.

Now i like to work on the assembler assembler1c.py, the current version is not proces aware, it assembles 3 codeblocks, loader, kernel and program, and assebles them in (what i call from now) in kernel mode. It uses a globel memory area (assembler_var_pointer) for vars and buffer, and is using prg_start as base adres per file to assemble

I think i need a new assembler directive, to tell the assembler its compiling a user proces (0,1,2,3) instead of a kernel file (like loader3.asm, kernel3.asm). the new directive also init the stacksize of a proces (default = 32) so the assembler can calutate the memory off-sets (the size of 1k processpace is fixed, for now).
PC = start proces block
SP = start proces block + 1024
var space = SP - stacksize

the prog_start parameter of the assembler is used to calculate the proces/context start adres, where user proces 0 == context 1 since context p is the kernel.

start adres of context 1 = prog_start + pid * 1024

when compiling an proces source, the kernelsymbols must be availble, because the can be used in the processes. earlier i introduced the restore flag = True when the symbols must be restored to the previous state

by default the assembler run in kernel mode and stores var/buffers in the globel memory space from assembler_var_pointer and is using the system SP
when the assembler see the ".PROCES <id> [<stacksize>] directive 
the assembler needs to keep track of the local (proces) SP and var_space

1 sourcefile can have multiple .PROCES directives, but must start with a directive and not in combination with files in kernelmode
and for compiling an proces the restore flag must be true so after compiling only the kernel symbols are known.

prog_start is used to calculate the adresses for the processes, even when .PROCES 3 in a seperate sourcefile, is the same prog_start (must be) used

* All diff must be to/from the current baseline
* DO NOT PLACE A COMMENTS AFTER AN INSCTRUCTIONS. The assemblers expects comments (;) always starts at a newline


report on this plan



====
Please look to /assembler1b.py and /cpu1.py, after the freeze the first generation of the Stern-I project as TAG STERN-Iv1, i wanne build the next generation with proces management support.

Herefore i did an CPU upgrade to the current cpu1.py, this new CPU supports the context switch instruction (cxtsw) i need for proces management.
the working od cxtsw is to 'return from interrupt and switch" "rts <adres>. since an context switch is (mostly) interrupt driven, the return part of the instuction will restore the state before the interrupt, the switch part will save the current context and load the new context to run. the ("pcb") information is stored in memory on the CPU

now i need to work on the softwarestack, asm/loader3.asm with contains lowlevel (interrupt) routines to communicatie with hardware.
and the asm/kernelv2.asm where the current file reflexs the first version of the Stern-I.

for now i leave the loaderV3.asm as is and i focus on the kernel.
The workingfile for this is asm/kernel3.asm.

- the new kernel starts from 1024 and is
- intitialize the stern computer
- keep track of the active processes (at start, just 1 kernel pid=0)
- a service routine to switch round robin tru the active processen
- be able to start up to 4 user processes
- has an runtime environment, like asm/incl/stacks_runtie.asm, to keep the processes small
- it must fit in 2k of memory 

important you need to remember:
* Since i don't have processes to run, i can live with the old stacks_runtime.
* the new CPU is taking care of PCB with the cxtsw instruction
* DO NOT PLACE A COMMENTS AFTER AN INSCTRUCTIONS. The assemblers expects comments (;) always starts at a newline

please check the current codebase give an status report


in this step, make the CPU context aware. 

the idea is an new CPU instruction to 'return from interrupt and switch" "rts <adres>. since an context switch is (mostly) interrupt driven, the return part of the instuction will restore the state before the interrupt, the switch part will save the current context and load the new context to run. the ("pcb") information is stored in memory on the CPU

by default the CPU starts running the kernel and can run 4 user processes. The kernel proces is dispatching the processes based on a service interrupt called by the RTC. since the cxt-switch happens in interrupt mode, a previous interrupt will finish first, before the switch is executed

each proces takes 1024 adresses. and the proces-blocks starts from start_prog (programmemory) if that context is new it saves the general registers =0 , and for PC = program start + (context number * 1024), and for SP =  (program start + (context number * 1024)) + 1024


please report on my ideas on this concept

Let change the assembler

A new instruction (eg ctxswith <pointer_next_ctx>) saves the current context (Registers, program counter, stack pointer and the statusbit). and loads the new context. the information is stored in a 'cache' on the CPU

the CPU needs a extra register to hold the base adres, in this case the proces memory starts at programmemory (start_prog). to calculate each proces startadres. each proces takes 1024 adresses.

by default the CPU start running in kernel-mode and can run 4 processes in user-mode. The kernel proces is dispatching the processes based on a service interrupt called by the RTC 

when ctxswitch cpu instruction is called, all information is save by context number and load the information from the next context, 
if that context is new it saves the general registers =0 , and for PC = program start + (context number * 1024), and for SP =  (program start + (context number * 1024)) + 1024

since the cxt-switch happens in interrupt mode, a previous interrupt will finish first, before the switch is executed

please check my ideas on this concept