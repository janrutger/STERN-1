
have a look on the current status of the Stern1 project. This version is supporting multiprocessing
the system loads the software: loader (asm/loader3.asm) containts lowlevel drivers, the kernel /asm/kernel3.asm, loads the kernel
and two user processes. afer loading, the kernel starts and starts the processes calling int ~SYSCALL_SET_PROCESS_READY

this is working, but when the payload of BOTH user processes calling the print_to_BCD routine to print A to the screen, the computer will crash with an memory exeption.
print_to_BCD is part op the printing routines /asm/incl/printing.asm and is included in the loader3.asm

[Instance 0] Loading binaries from /home/janrutger/git/STERN-1/bin...
[Instance 0] Starting CPU at address: 1024
DEBUG CPU: Loaded context for ID 0: PC=1024, SP=14335
[Instance 0] Starting Device IO loop...
CPU Monitor: Started.
DEBUG CPU: Loaded context for ID 1: PC=4096, SP=5119
DEBUG CPU: Loaded context for ID 2: PC=5120, SP=6143
DEBUG CPU: Loaded context for ID 0: PC=1033, SP=14335
DEBUG CPU: Loaded context for ID 1: PC=4101, SP=5119
DEBUG CPU: Loaded context for ID 2: PC=5124, SP=6143
Exception in thread Thread-1 (run):
Traceback (most recent call last):
  File "/usr/lib/python3.11/threading.py", line 1038, in _bootstrap_inner
    self.run()
  File "/usr/lib/python3.11/threading.py", line 975, in run
    self._target(*self._args, **self._kwargs)
  File "/home/janrutger/git/STERN-1/cpuNG.py", line 214, in run
    self.memory.write(adres, str(self.registers[op1]))
  File "/home/janrutger/git/STERN-1/memory.py", line 8, in write
    self.validAddress(address)
  File "/home/janrutger/git/STERN-1/memory.py", line 28, in validAddress
    raise IndexError(f"Memory address {address} out of range (0-{len(self.memory)-1})")
IndexError: Memory address 16384 out of range (0-16383)

i think the problem lies in interrupt handling, the user proces disable the intrrupt before callin print_to_BCD, and @print_nl is calling int 4 when it needs to scroll the screen. but the RTI from this last interrupt, enables interrupt before the print_to_BCD returns to the user proces


report on this












Please check the current codebase, after the freeze the first generation of the Stern-I project as TAG STERN-Iv1, i wanne build the next generation with proces management support.

Herefore i did an CPU upgrade to the current cpu1.py, this new CPU supports the context switch instruction (cxtsw) i need for proces management.
the working od cxtsw is to 'return from interrupt and switch" "rts <adres>. since an context switch is (mostly) interrupt driven, the return part of the instuction will restore the state before the interrupt, the switch part will save the current context and load the new context to run. the ("pcb") information is stored in memory on the CPU

I changes the kernel (asm/kernel3.asm) so it know about the processes and schedule the processes.

Now i like to work on the assembler assembler1c.py, the current version is not proces aware, it assembles 3 codeblocks, loader, kernel and program, and assebles them in (what i call from now) in kernel mode. It uses a globel memory area (assembler_var_pointer) for vars and buffer, and is using prg_start as base adres per file to assemble

I think i need a new assembler directive, to tell the assembler its compiling a user proces (1,2,3,4) instead of a kernel file (like loader3.asm, kernel3.asm). the new directive also init the stacksize of a proces (default = 32) so the assembler can calutate the memory off-sets (the size of 1k processpace is fixed, for now).
PC = start proces block
SP = start proces block + 1024
var space = SP - stacksize

the prog_start parameter of the assembler is used to calculate the proces/context start adres.

start adres of context 1 = prog_start + pid * 1024

when compiling an proces source, the kernelsymbols must be availble, because the can be used in the processes. earlier i introduced the restore flag = True when the symbols must be restored to the previous state

by default the assembler run in kernel mode and stores var/buffers in the globel memory space from assembler_var_pointer and is using the system SP
when the assembler see the ".PROCES <id> [<stacksize>] directive 
the assembler needs to keep track of the local (proces) SP and var_space

1 sourcefile can have multiple .PROCES directives, but must start with a directive and not in combination with files in kernelmode
and for compiling an proces the restore flag must be true so after compiling only the kernel symbols are known.

prog_start is used to calculate the adresses for the processes, even when .PROCES 3 in a seperate sourcefile, is the same prog_start (must be) used

* All diff must be to/from the current baseline
* DO NOT PLACE A COMMENTS AFTER AN INSCTRUCTIONS. The assemblers expects comments (;) always starts at a newline


report on this plan, i think i did all of this



====
Please look to /assembler1b.py and /cpu1.py, after the freeze the first generation of the Stern-I project as TAG STERN-Iv1, i wanne build the next generation with proces management support.

Herefore i did an CPU upgrade to the current cpu1.py, this new CPU supports the context switch instruction (cxtsw) i need for proces management.
the working od cxtsw is to 'return from interrupt and switch" "rts <adres>. since an context switch is (mostly) interrupt driven, the return part of the instuction will restore the state before the interrupt, the switch part will save the current context and load the new context to run. the ("pcb") information is stored in memory on the CPU

now i need to work on the softwarestack, asm/loader3.asm with contains lowlevel (interrupt) routines to communicatie with hardware.
and the asm/kernelv2.asm where the current file reflexs the first version of the Stern-I.

for now i leave the loaderV3.asm as is and i focus on the kernel.
The workingfile for this is asm/kernel3.asm.

- the new kernel starts from 1024 and is
- intitialize the stern computer
- keep track of the active processes (at start, just 1 kernel pid=0)
- a service routine to switch round robin tru the active processen
- be able to start up to 4 user processes
- has an runtime environment, like asm/incl/stacks_runtie.asm, to keep the processes small
- it must fit in 2k of memory 

important you need to remember:
* Since i don't have processes to run, i can live with the old stacks_runtime.
* the new CPU is taking care of PCB with the cxtsw instruction
* DO NOT PLACE A COMMENTS AFTER AN INSCTRUCTIONS. The assemblers expects comments (;) always starts at a newline

please check the current codebase give an status report


in this step, make the CPU context aware. 

the idea is an new CPU instruction to 'return from interrupt and switch" "rts <adres>. since an context switch is (mostly) interrupt driven, the return part of the instuction will restore the state before the interrupt, the switch part will save the current context and load the new context to run. the ("pcb") information is stored in memory on the CPU

by default the CPU starts running the kernel and can run 4 user processes. The kernel proces is dispatching the processes based on a service interrupt called by the RTC. since the cxt-switch happens in interrupt mode, a previous interrupt will finish first, before the switch is executed

each proces takes 1024 adresses. and the proces-blocks starts from start_prog (programmemory) if that context is new it saves the general registers =0 , and for PC = program start + (context number * 1024), and for SP =  (program start + (context number * 1024)) + 1024


please report on my ideas on this concept

Let change the assembler

A new instruction (eg ctxswith <pointer_next_ctx>) saves the current context (Registers, program counter, stack pointer and the statusbit). and loads the new context. the information is stored in a 'cache' on the CPU

the CPU needs a extra register to hold the base adres, in this case the proces memory starts at programmemory (start_prog). to calculate each proces startadres. each proces takes 1024 adresses.

by default the CPU start running in kernel-mode and can run 4 processes in user-mode. The kernel proces is dispatching the processes based on a service interrupt called by the RTC 

when ctxswitch cpu instruction is called, all information is save by context number and load the information from the next context, 
if that context is new it saves the general registers =0 , and for PC = program start + (context number * 1024), and for SP =  (program start + (context number * 1024)) + 1024

since the cxt-switch happens in interrupt mode, a previous interrupt will finish first, before the switch is executed

please check my ideas on this concept